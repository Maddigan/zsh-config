# -*- mode: shell-script -*-
# vim: ft=zsh fdm=marker :

bindkey '[1;5C' forward-word
bindkey '[1;5D' backward-word
bindkey '[7~' beginning-of-line
bindkey '[8~' end-of-line
bindkey '[3~' delete-char

######################################################################

my-history-beginning-search-backward()
{
    local SPACES TMP
    TMP="${LBUFFER## #}"
    SPACES="${LBUFFER/$TMP/}"
    LBUFFER=$TMP
    zle history-beginning-search-backward
    LBUFFER="${SPACES}${TMP}"
}
my-history-beginning-search-forward()
{
    local SPACES TMP
    TMP="${LBUFFER## #}"
    SPACES="${LBUFFER/$TMP/}"
    LBUFFER=$TMP
    zle history-beginning-search-forward
    LBUFFER="${SPACES}${LBUFFER}"
}
zle -N my-history-beginning-search-backward
zle -N my-history-beginning-search-forward
bindkey '^p' my-history-beginning-search-backward
bindkey '^n' my-history-beginning-search-forward

clear-screen-hard()
{
    tput reset
    zle redisplay
}
zle -N clear-screen-hard
bindkey '^Xl' clear-screen-hard

######################################################################

for i in '``' '()' '{}' '[]'; do
    eval "function zle-paired-input-'$i'()
    {
        LBUFFER="'$LBUFFER'"'$i[1]'
        RBUFFER='$i[2]'"'$RBUFFER'"
    }"
    zle -N zle-paired-input-"$i"
    bindkey "$i[1]" zle-paired-input-"$i"
done
for i in \" \'; do
    eval "function zle-paired-input-\\$i()
    {
        LBUFFER="'$LBUFFER'"\\$i
        RBUFFER=\\$i"'$RBUFFER'"
    }"
    zle -N zle-paired-input-"$i"
    bindkey "$i" zle-paired-input-"$i"
done

######################################################################

autoload edit-command-line
zle -N edit-command-line
bindkey '^X^E' edit-command-line

######################################################################

last-arg-basename-widget()
{
    LBUFFER+=$_:t:q
}
zle -N last-arg-basename-widget
bindkey '>' last-arg-basename-widget

######################################################################

autoload -U smart-insert-last-word && zle -N smart-insert-last-word insert-last-word

background_n_disown_widget()
{
    bg && disown
    zle reset-prompt
}
zle -N background_n_disown_widget
bindkey '^Z' background_n_disown_widget

bindkey 'j' vi-find-next-char

######################################################################

expand-path()
{
    autoload -U modify-current-argument
    modify-current-argument '$ARG:Q:A:q'
}
zle -N expand-path
bindkey '^Xp' expand-path

######################################################################

zle-mkdir()
{
    autoload -U modify-current-argument
    function mkdir-worker() {
        REPLY=$~1
        zle -M "Are you sure you want to create directory \"$REPLY\"? [y/n]"
        zle -R
        local KEY
        read -k KEY
        if [ "$KEY" = y ]; then
            mkdir -p $REPLY 2> /dev/null
            zle -M "Directory \"$REPLY\" successfully created."
            REPLY+=/
        else
            zle -M ""
        fi
    }
    modify-current-argument mkdir-worker
}
zle -N zle-mkdir
bindkey '\em' zle-mkdir

######################################################################

zle-insert-line()
{
    echo -n "\e[0G\e[K"
    perl -Mutf8 -CS -e 'print "\N{U+2500}" x $ARGV[0], \n' $COLUMNS
    zle redisplay
}
zle -N zle-insert-line
bindkey '\el' zle-insert-line

######################################################################

bindkey -s 'r' "^u . ranger\n"

######################################################################

prepend-space()
{
    LBUFFER=" ${LBUFFER## #}"
}
zle -N prepend-space
bindkey ' ' prepend-space

######################################################################

exec-emacs-here()
{
    exec emacsclient -c -n .
}
zle -N exec-emacs-here
bindkey '^Xd' exec-emacs-here

######################################################################

autoload predict-on predict-off
my-predict-on()
{
    zstyle ':completion:*' completer _expand _complete _ignored
    predict-on
}
my-predict-off()
{
    zstyle ':completion:*' completer _expand _complete _ignored _approximate
    predict-off
}
zle -N my-predict-on
bindkey '^X-' my-predict-on
zle -N my-predict-off
bindkey '^X=' my-predict-off

######################################################################

my-create-generic-completion()
{
    autoload -U split-shell-arguments
    local reply REPLY REPLY2

    split-shell-arguments

    local i
    for ((i = $#reply-1; i > 0; --i)); do
        case $reply[i] in
            ';'|'|'|'||'|'&'|'&&'|'sudo')
                break
                ;;
        esac
    done

    compdef _gnu_generic $reply[i+2]
}
zle -N my-create-generic-completion
bindkey '^X^H' my-create-generic-completion

######################################################################

if (( $+commands[fzf] )); then
    fzf-cd() {
        if [ -n "$NUMERIC" ]; then
            cd ~/projects
        fi
        cd "${$(command find -L . \( -path '*/\.*' -o -fstype 'dev' -o -fstype 'proc' \) -prune \
    -o -type d -print 2> /dev/null | sed 1d | cut -b3- | fzf +m):-.}"
        zle reset-prompt
    }
    zle     -N    fzf-cd
    bindkey '\ec' fzf-cd

    __fsel() {
        command find -L . \( -path '*/\.*' -o -fstype 'dev' -o -fstype 'proc' \) -prune \
                -o -type f -print \
                -o -type d -print \
                -o -type l -print 2> /dev/null | sed 1d | cut -b3- | fzf -m | while read item; do
            printf '%q ' "$item"
        done
        echo
    }

    if [ -n "$TMUX_PANE" -a ${FZF_TMUX:-1} -ne 0 -a ${LINES:-40} -gt 15 ]; then
        fzf-file-widget() {
            local height
            height=${FZF_TMUX_HEIGHT:-40%}
            if [[ $height =~ %$ ]]; then
                height="-p ${height%\%}"
            else
                height="-l $height"
            fi
            tmux split-window $height "zsh -c 'source ~/.fzf.zsh; tmux send-keys -t $TMUX_PANE \"\$(__fsel)\"'"
        }
    else
        fzf-file-widget() {
            LBUFFER="${LBUFFER}$(__fsel)"
            zle redisplay
        }
    fi
    zle     -N   fzf-file-widget
    bindkey '^T' fzf-file-widget
fi

######################################################################

# copied from Valodim's config
# just type '...' to get '../..'
function rationalise-dot() {
  local MATCH dir
  if [[ $LBUFFER =~ '(^|/| |    |'$'\n''|\||;|&)\.\.$' ]]; then
    LBUFFER+=/
    zle self-insert
    zle self-insert
    dir=${${(z):-x $LBUFFER}[-1]}
    [[ -e $dir ]] && zle -M $dir(:a)
  elif [[ $LBUFFER[-1] == '.' ]]; then
    zle self-insert
    dir=${${(z):-x $LBUFFER}[-1]}
    [[ -e $dir ]] && zle -M $dir(:a)
  else
    zle self-insert
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
# without this, typing a . aborts incremental history search
bindkey -M isearch . self-insert
